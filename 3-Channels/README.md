# Channels
Here we have a code snippet, where a goroutine is making a computation.

~~~go
func main() {
    go func(a, b int) {
        c := a + b
    }(1,2)
}
~~~

We want to get the result of that computation in our main routine without having to share the memory. This is where channels come into picture.
- Channels are used to communicate data between goroutines.
- They also help in synchronizing the execution of the goroutines. One goroutine can let know another goroutine in what stage of the computation they are in, and synchronize their execution.
- Channels are typed. They are used to send and receive values of a particular type.
- They are thread safe, so the channel variables can be used to send and receive values concurrently by multiple goroutines.

## Declare and initialize
It is very easy to create channels. Here we declare a viarable with the `chan` keyword, followed by the type. The default value of the channel is `nil`.

~~~go
var ch chan T
~~~~

We need to use built-in-function `make` to allocate memory for the channel.

~~~go
var ch chan T
ch = make(chan T)
~~~

We can also use a short variable declaration with `make`, which declares and allocates memory for the channel in one statement.

~~~go
ch := make(chan T)
~~~

## <- Operator
Pointer operator is used for sending and receiving the value from a channel. The arrow direction indicates the direction of the data flow.

- For send the arrow direction indicates that the value is being written to the channel.

~~~go
ch <- v
~~~

- For receive, the arrow direction indicates that the value is being received form the channel and copied to the variable.

~~~go
v = <-ch
~~~

## Channels are blocking
The sending goroutine is going to block until there is a corresponding receiver goroutine ready to receive the value.

~~~go
// Goroutines wait for a receiver to be ready
ch <- value
~~~

Similarly, the receiver goroutine is going to block until there is a corresponding sender goroutine sending the value.

~~~go
// Goroutines wait for a value to be sent
<- ch
~~~

It is the responsability of the channel to make the goroutine runnable again once it has data.

## Close
Closing of the channel is very useful for the sender goroutine to indicate to the receiver goroutine that the sender has no more value to send on the channel. The receiver can then unblock and proceed with its other computation.

~~~go
value, ok = <- ch
~~~

Receive returns two values:
- The first one is a received value from the channel. 
- The second is a boolean value, which indicates whether the value that is being read from the channel is a value that is generated by a write or a default value that is being generated by a close of the channel.
This second return value is very useful to determine whether the value is from write or whether the value is from close.


## Range, Buffered channels
The receiver goroutine can use range to receive a sequence of values from the channel. The loop automatically breaks when the channel is closed. This is why the range does not return the second boolean value.

## Unbuffered channels
The channels that we have been creating till now are unbuffered channels. There is no buffer between the sender goroutine and the receiver goroutine. Since there is no buffer, the sender goroutine will block until there is a receiver for the value. Likewise, the receiver goroutine will block until there is a sender for the value.

In buffered channels, there is a buffer between the sender and the receiver goroutine. We can specify the capacity, that is the buffer size, which indicates the number of elements that can be sent without the receiver being ready.

The sender can keep sending the values without blocking till the buffer gets full. The receiver can keep receiving the values without blocking till the buffer gets empty. 

The buffered channels are in-memory FIFO queues, so the element that is sent first will be the element that will be read first.

## Channel direction
When using channels as function parameters, we can specify if a channel is meant to only send or receive values.
This specificity increases the type safety of the program.

~~~go
func pong(in <-chan string, out chan<- string){}
~~~

In the example above, `in` is a receive only channel (`<-chan`). `out` is a send only channel (`chan<-`). The pong function can use in only to receive values. If we tried to send values on this channel, the compiler will report an error.

## Default value

Default value for channels is `nil`. So we should allocate memory by using the built-in function `make`.
~~~go
var ch chan interface{}
~~~~
If that does not happen and we try to send or receive on that channel, then it is going to block forever.

~~~go
var ch chan interface{}
<-ch
ch<- struct{}{}
~~~

Similarly, closing on the `nil` channel will cause a `panic`, so we should always make sure that the channels are initialized with `make`.

~~~go
var ch chan interface{}
close(ch)
~~~

Make sure channels are initialized first.

## Ownership
The best practice is that the goroutine that creates the channel will be the one that write to it, and also the responsable for closing it. The owner of a channel is the goroutine that instantiates, writes and closes it. Channel *utilizers* only have a read-only view into the channel.

Establishing the ownership of the channel will help us avoid deadlocks and panics, and it will help in avoiding scenarios like writing to a nil channel, writing to a closed channel, or closing it more than once.

## Deep dive
In this module we will try to understand the mechanics behind channels.
We use `make` to create channels

~~~go
ch := make(chan int, 3)
~~~

Here we are creating a buffered channel with three elements. Internally, the channels are represented by the `hchan` structure.

~~~go
type hchan struct {
    qcount      uint // total data in the queue
    dataqsiz    uint // size of the circular queue
    buf         unsafe.Pointer // points to an array of dataqsiz elements
    elemsize    uint16
    closed      uint32
    elemtype     *_type // element type
    sendx       uint // send index
    recvx       uint // receive index
    recvq       waitq // list of recv waiters
    sendq       waitq // list of send waiters

    // lock protects all fields in hchan
    lock        mutex
}

type waitq struct {
    first   *sudog
    last    *sudog
}
~~~

- **mutex lock**: any goroutine doing any channel operation must first acquire the lock on the channel.
- **buf**: is a circular ring buffer where the actual data is stored. This is used only for the buffered channels.
- **dataqsiz**: the size of the buffer.
- **qcount**: indicates a total of data elements in the queue.
- **sendx and recvx**: indicate the current index of the buffer from where it can send or receive data.
- **recvq and sendq**: are the waiting queues which are used to store blocked goroutines. These were blocked while they were trying to send or receive data from the channel.
- **waitq**: is the linked list of goroutines. The elements in the list are represented by the `sudog` struct.

~~~go
// sudog represents a g in a wait list, such as for sending/receiving on a channel
type sudog struct {
    g *g

    next    *sudog
    prev    *sudog
    elem    unsafe.Pointer // data element(may point to stack)
    // ...
    c       *hchan // channel
}
~~~

In the sudog struct we have

- **g**, which is a reference to the goroutine
- **elem**: pointer to memory, which contains the value to be sent, or to which the received value will be written to.

To go back to the previous example

~~~go
ch := make(chan int, 3)
~~~

When we create a channel, hchan struct is allocated in the heap. `make` returns a reference to the allocated memory. Since ch is a pointer, it can be sent between the functions which can perform, send or receive operations on the channel. 

Let us now look at what happens when we send or receive on a buffered channel

~~~go
ch := make(chan int, 3)
// G1 - goroutine
func G1(ch chan<- int) {
    for _, v := range []int{1, 2, 3, 4} {
        ch <- v
    }
}

// G2 - goroutine
func G2(ch <-chan int) {
    for v := range ch {
        fmt.Println(v)
    }
}
~~~

In this code snippet we have 2 goroutines. Goroutine G1 is sending a sequence of values into the channel, and goroutine G2 is receiving the sequence of values by ranging over the channel.

When we create a channel this will be the representation.

....VOLVER A VER REPRESENTACION DE LA LECCIÓN 28


- There is no memory share between goroutines
- Goroutines copy elements into and from hchan
- hchan is protected by mutex lock

*"Do not communicate by sharing memory; instead, share memory by communicating"*