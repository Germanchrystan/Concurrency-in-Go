# Channels
Here we have a code snippet, where a goroutine is making a computation.

~~~go
func main() {
    go func(a, b int) {
        c := a + b
    }(1,2)
}
~~~

We want to get the result of that computation in our main routine without having to share the memory. This is where channels come into picture.
- Channels are used to communicate data between goroutines.
- They also help in synchronizing the execution of the goroutines. One goroutine can let know another goroutine in what stage of the computation they are in, and synchronize their execution.
- Channels are typed. They are used to send and receive values of a particular type.
- They are thread safe, so the channel variables can be used to send and receive values concurrently by multiple goroutines.

## Declare and initialize
It is very easy to create channels. Here we declare a viarable with the `chan` keyword, followed by the type. The default value of the channel is `nil`.

~~~go
var ch chan T
~~~~

We need to use built-in-function `make` to allocate memory for the channel.

~~~go
var ch chan T
ch = make(chan T)
~~~

We can also use a short variable declaration with `make`, which declares and allocates memory for the channel in one statement.

~~~go
ch := make(chan T)
~~~

## <- Operator
Pointer operator is used for sending and receiving the value from a channel. The arrow direction indicates the direction of the data flow.

- For send the arrow direction indicates that the value is being written to the channel.

~~~go
ch <- v
~~~

- For receive, the arrow direction indicates that the value is being received form the channel and copied to the variable.

~~~go
v = <-ch
~~~

## Channels are blocking
The sending goroutine is going to block until there is a corresponding receiver goroutine ready to receive the value.

~~~go
// Goroutines wait for a receiver to be ready
ch <- value
~~~

Similarly, the receiver goroutine is going to block until there is a corresponding sender goroutine sending the value.

~~~go
// Goroutines wait for a value to be sent
<- ch
~~~

It is the responsability of the channel to make the goroutine runnable again once it has data.

## Close
Closing of the channel is very useful for the sender goroutine to indicate to the receiver goroutine that the sender has no more value to send on the channel. The receiver can then unblock and proceed with its other computation.

~~~go
value, ok = <- ch
~~~

Receive returns two values:
- The first one is a received value from the channel. 
- The second is a boolean value, which indicates whether the value that is being read from the channel is a value that is generated by a write or a default value that is being generated by a close of the channel.
This second return value is very useful to determine whether the value is from write or whether the value is from close.


## Range, Buffered channels
The receiver goroutine can use range to receive a sequence of values from the channel. The loop automatically breaks when the channel is closed. This is why the range does not return the second boolean value.

## Unbuffered channels
The channels that we have been creating till now are unbuffered channels. There is no buffer between the sender goroutine and the receiver goroutine. Since there is no buffer, the sender goroutine will block until there is a receiver for the value. Likewise, the receiver goroutine will block until there is a sender for the value.

In buffered channels, there is a buffer between the sender and the receiver goroutine. We can specify the capacity, that is the buffer size, which indicates the number of elements that can be sent without the receiver being ready.

The sender can keep sending the values without blocking till the buffer gets full. The receiver can keep receiving the values without blocking till the buffer gets empty. 

The buffered channels are in-memory FIFO queues, so the element that is sent first will be the element that will be read first.

## Channel direction
When using channels as function parameters, we can specify if a channel is meant to only send or receive values.
This specificity increases the type safety of the program.

~~~go
func pong(in <-chan string, out chan<- string){}
~~~

In the example above, `in` is a receive only channel (`<-chan`). `out` is a send only channel (`chan<-`). The pong function can use in only to receive values. If we tried to send values on this channel, the compiler will report an error.

## Default value

Default value for channels is `nil`. So we should allocate memory by using the built-in function `make`.
~~~go
var ch chan interface{}
~~~~
If that does not happen and we try to send or receive on that channel, then it is going to block forever.

~~~go
var ch chan interface{}
<-ch
ch<- struct{}{}
~~~

Similarly, closing on the `nil` channel will cause a `panic`, so we should always make sure that the channels are initialized with `make`.

~~~go
var ch chan interface{}
close(ch)
~~~

Make sure channels are initialized first.

## Ownership
The best practice is that the goroutine that creates the channel will be the one that write to it, and also the responsable for closing it. The owner of a channel is the goroutine that instantiates, writes and closes it. Channel *utilizers* only have a read-only view into the channel.

Establishing the ownership of the channel will help us avoid deadlocks and panics, and it will help in avoiding scenarios like writing to a nil channel, writing to a closed channel, or closing it more than once.