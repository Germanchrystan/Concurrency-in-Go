# Channels
Here we have a code snippet, where a goroutine is making a computation.

~~~go
func main() {
    go func(a, b int) {
        c := a + b
    }(1,2)
}
~~~

We want to get the result of that computation in our main routine without having to share the memory. This is where channels come into picture.
- Channels are used to communicate data between goroutines.
- They also help in synchronizing the execution of the goroutines. One goroutine can let know another goroutine in what stage of the computation they are in, and synchronize their execution.
- Channels are typed. They are used to send and receive values of a particular type.
- They are thread safe, so the channel variables can be used to send and receive values concurrently by multiple goroutines.

## Declare and initialize
It is very easy to create channels. Here we declare a viarable with the `chan` keyword, followed by the type. The default value of the channel is `nil`.

~~~go
var ch chan T
~~~~

We need to use built-in-function `make` to allocate memory for the channel.

~~~go
var ch chan T
ch = make(chan T)
~~~

We can also use a short variable declaration with `make`, which declares and allocates memory for the channel in one statement.

~~~go
ch := make(chan T)
~~~

## <- Operator
Pointer operator is used for sending and receiving the value from a channel. The arrow direction indicates the direction of the data flow.

- For send the arrow direction indicates that the value is being written to the channel.

~~~go
ch <- v
~~~

- For receive, the arrow direction indicates that the value is being received form the channel and copied to the variable.

~~~go
v = <-ch
~~~

## Channels are blocking
The sending goroutine is going to block until there is a corresponding receiver goroutine ready to receive the value.

~~~go
// Goroutines wait for a receiver to be ready
ch <- value
~~~

Similarly, the receiver goroutine is going to block until there is a corresponding sender goroutine sending the value.

~~~go
// Goroutines wait for a value to be sent
<- ch
~~~

It is the responsability of the channel to make the goroutine runnable again once it has data.

## Close
Closing of the channel is very useful for the sender goroutine to indicate to the receiver goroutine that the sender has no more value to send on the channel. The receiver can then unblock and proceed with its other computation.

~~~go
value, ok = <- ch
~~~

Receive returns two values:
- The first one is a received value from the channel. 
- The second is a boolean value, which indicates whether the value that is being read from the channel is a value that is generated by a write or a default value that is being generated by a close of the channel.
This second return value is very useful to determine whether the value is from write or whether the value is from close.
